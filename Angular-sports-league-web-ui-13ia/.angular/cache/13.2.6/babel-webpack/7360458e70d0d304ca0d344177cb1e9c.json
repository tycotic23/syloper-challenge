{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as i0 from \"@angular/core\";\nexport let LeagueService = /*#__PURE__*/(() => {\n  class LeagueService {\n    constructor() {\n      this.urlAPI = \"http://localhost:3001/api/v1/\";\n    }\n    /**\r\n     * Sets the match schedule.\r\n     * Match schedule will be given in the following form:\r\n     * [\r\n     *      {\r\n     *          matchDate: [TIMESTAMP],\r\n     *          stadium: [STRING],\r\n     *          homeTeam: [STRING],\r\n     *          awayTeam: [STRING],\r\n     *          matchPlayed: [BOOLEAN],\r\n     *          homeTeamScore: [INTEGER],\r\n     *          awayTeamScore: [INTEGER]\r\n     *      },\r\n     *      {\r\n     *          matchDate: [TIMESTAMP],\r\n     *          stadium: [STRING],\r\n     *          homeTeam: [STRING],\r\n     *          awayTeam: [STRING],\r\n     *          matchPlayed: [BOOLEAN],\r\n     *          homeTeamScore: [INTEGER],\r\n     *          awayTeamScore: [INTEGER]\r\n     *      }\r\n     * ]\r\n     *\r\n     * @param {Array} matches List of matches.\r\n     */\n\n\n    setMatches(matches) {\n      this.matches = matches;\n    }\n    /**\r\n     * Returns the full list of matches.\r\n     *\r\n     * @returns {Array} List of matches.\r\n     */\n\n\n    getMatches() {\n      return this.matches;\n    }\n    /**\r\n     * Returns the leaderBoard in a form of a list of JSON objecs.\r\n     *\r\n     * [\r\n     *      {\r\n     *          teamName: [STRING]',\r\n     *          matchesPlayed: [INTEGER],\r\n     *          goalsFor: [INTEGER],\r\n     *          goalsAgainst: [INTEGER],\r\n     *          points: [INTEGER]\r\n     *      },\r\n     * ]\r\n     *\r\n     * @returns {Array} List of teams representing the leaderBoard.\r\n     */\n\n\n    getLeaderBoard() {\n      return this.leaderBoard;\n    }\n\n    generateLeaderBoard(matches) {\n      let processMatches = [];\n      matches.forEach(match => {\n        //obtener puntaje\n        let pointsHomeScored = 0;\n        let pointsAwayScored = 0;\n\n        if (match.matchPlayed) {\n          if (match.homeTeamScore == match.awayTeamScore) {\n            pointsAwayScored = 1;\n            pointsHomeScored = 1;\n          } else if (match.homeTeamScore > match.awayTeamScore) {\n            pointsHomeScored = 3;\n          } else {\n            pointsAwayScored = 3;\n          }\n        } //modificar puntos del homeTeam\n\n\n        if (!processMatches[match.homeTeam]) {\n          processMatches[match.homeTeam] = {\n            teamName: match.homeTeam,\n            matchesPlayed: match.matchPlayed ? 1 : 0,\n            goalsFor: match.homeTeamScore,\n            goalsAgainst: match.awayTeamScore,\n            points: pointsHomeScored\n          };\n        } else {\n          processMatches[match.homeTeam].matchesPlayed += match.matchPlayed ? 1 : 0;\n          processMatches[match.homeTeam].goalsFor += match.homeTeamScore;\n          processMatches[match.homeTeam].goalsAgainst += match.awayTeamScore;\n          processMatches[match.homeTeam].points += pointsHomeScored;\n        } //modificar puntos del awayTeam\n\n\n        if (!processMatches[match.awayTeam]) {\n          processMatches[match.awayTeam] = {\n            teamName: match.awayTeam,\n            matchesPlayed: match.matchPlayed ? 1 : 0,\n            goalsFor: match.awayTeamScore,\n            goalsAgainst: match.homeTeamScore,\n            points: pointsAwayScored\n          };\n        } else {\n          processMatches[match.awayTeam].matchesPlayed += match.matchPlayed ? 1 : 0;\n          processMatches[match.awayTeam].goalsFor += match.awayTeamScore;\n          processMatches[match.awayTeam].goalsAgainst += match.homeTeamScore;\n          processMatches[match.awayTeam].points += pointsAwayScored;\n        }\n      }); //quedarse solo con las valores sin las claves\n\n      let flatProcesMatches = [];\n\n      for (let key in processMatches) {\n        flatProcesMatches.push(processMatches[key]);\n      }\n\n      return flatProcesMatches;\n    }\n    /**\r\n     * Asynchronic function to fetch the data from the server and set the matches.\r\n     */\n\n\n    fetchData() {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          //obtener el codigo de acceso\n          let response = yield fetch(this.urlAPI + \"getAccessToken\");\n\n          if (!response.ok) {\n            throw new Error(`Response status: ${response.status}`);\n          }\n\n          const json = yield response.json();\n\n          if (!json.access_token) {\n            throw new Error(`Response status: ${response.status}`);\n          } //traer los partidos\n\n\n          response = yield fetch(this.urlAPI + \"getAllMatches\", {\n            headers: {\n              \"Authorization\": \"Bearer \" + json.access_token\n            }\n          });\n\n          if (!response.ok) {\n            throw new Error(`Response status: ${response.status}`);\n          }\n\n          const matchesBD = yield response.json();\n\n          if (!json.access_token) {\n            throw new Error(`Response status: ${response.status}`);\n          } //guardarlos en \"matches\"\n\n\n          const matches = matchesBD.matches;\n          this.setMatches(matches); //procesar los resultados\n\n          this.leaderBoard = this.generateLeaderBoard(this.matches); //ordenar los resultados\n\n          this.leaderBoard = this.order(this.leaderBoard);\n        } catch (error) {\n          console.error(error.message);\n        }\n      });\n    }\n    /* ordering */\n\n\n    orderSimple(teamResults) {\n      teamResults.sort((a, b) => a.points - b.points);\n      return teamResults;\n    }\n\n    groupByPoints(teamResults) {\n      return teamResults.reduce((acum, team) => {\n        acum[team.points] = acum[team.points] || [];\n        acum[team.points].push(team);\n        return acum;\n      }, {});\n    }\n\n    order(teamResults) {\n      //agrupar por puntos\n      let teamResultsByPoints = this.groupByPoints(teamResults); //convertir en array\n\n      let resultsArray = [];\n\n      for (let key in teamResultsByPoints) {\n        resultsArray.push(teamResultsByPoints[key]);\n      }\n\n      teamResultsByPoints = resultsArray.map(group => {\n        if (group.length == 1) {\n          return group;\n        } //ordenar los empatados en cada grupo\n        //criterio 1\n        //obtener los partidos solo de los equipos empatados\n\n\n        let filterMatches = this.matches.filter(match => {\n          return group.findIndex(team => team.teamName == match.awayTeam) != -1 && group.findIndex(team => team.teamName == match.homeTeam) != -1;\n        });\n        let newOrder = this.generateLeaderBoard(filterMatches);\n        this.orderSimple(newOrder); //revisar que no siga habiendo empates\n\n        let empates = [];\n        let hayEmpate = 0;\n        newOrder.forEach(team => {\n          if (!empates[team.points]) {\n            empates[team.points] = 1;\n          } else {\n            hayEmpate = 1;\n          }\n        }); //si no hay empate se aplica el criterio 1\n\n        if (!hayEmpate) {\n          //reordenamos group\n          group = newOrder.map(orden => {\n            return group.find(n => n.teamName === orden.teamName);\n          });\n          return group;\n        } //los demas criterios:\n\n        /* The second tiebreaker is goal difference.\r\n            The third tiebreaker is the number of scored goals.\r\n            The final tiebreaker is alphabetic ascending order by name.\r\n        */\n\n\n        group.sort((a, b) => {\n          let criterio2 = a.goalsFor - a.goalsFor - (b.goalsFor - b.goalsFor);\n\n          if (criterio2 != 0) {\n            return criterio2;\n          }\n\n          let criterio3 = a.goalsFor - b.goalsFor;\n\n          if (criterio3 != 0) {\n            return criterio3;\n          } //en su defecto ordenar alfabeticamente\n\n\n          return a.teamName.localeCompare(b.teamName);\n        });\n        return group;\n      }); //volver a desagrupar\n\n      let acum = [];\n\n      for (let key in teamResultsByPoints) {\n        for (let index in teamResultsByPoints[key]) {\n          acum.push(teamResultsByPoints[key][index]);\n        }\n      } //invertir el orden\n\n\n      return acum.reverse();\n    }\n\n  }\n\n  LeagueService.ɵfac = function LeagueService_Factory(t) {\n    return new (t || LeagueService)();\n  };\n\n  LeagueService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LeagueService,\n    factory: LeagueService.ɵfac,\n    providedIn: 'root'\n  });\n  return LeagueService;\n})();","map":null,"metadata":{},"sourceType":"module"}