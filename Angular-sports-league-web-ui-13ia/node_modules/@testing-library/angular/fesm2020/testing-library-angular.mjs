import * as i0 from '@angular/core';
import { SimpleChange, ChangeDetectorRef, NgZone, ApplicationInitStatus, Component } from '@angular/core';
import { TestBed, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { NoopAnimationsModule, BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { Router } from '@angular/router';
import { RouterTestingModule } from '@angular/router/testing';
import { configure as configure$1, prettyDOM, getQueriesForElement, waitFor as waitFor$1, waitForElementToBeRemoved as waitForElementToBeRemoved$1, screen as screen$1, within as within$1 } from '@testing-library/dom';
export { buildQueries, createEvent, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, isInaccessible, logDOM, logRoles, prettyDOM, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers } from '@testing-library/dom';

let config = {
    dom: {},
    defaultImports: [],
};
function configure(newConfig) {
    if (typeof newConfig === 'function') {
        // Pass the existing config out to the provided function
        // and accept a delta in return
        newConfig = newConfig(config);
    }
    // Merge the incoming config delta
    config = {
        ...config,
        ...newConfig,
    };
}
function getConfig() {
    return config;
}

const mountedFixtures = new Set();
const inject = TestBed.inject || TestBed.get;
async function render(sut, renderOptions = {}) {
    const { dom: domConfig, ...globalConfig } = getConfig();
    const { detectChanges: detectChangesOnRender = true, declarations = [], imports = [], providers = [], schemas = [], queries, wrapper = WrapperComponent, componentProperties = {}, componentProviders = [], excludeComponentDeclaration = false, routes = [], removeAngularAttributes = false, defaultImports = [], } = { ...globalConfig, ...renderOptions };
    configure$1({
        eventWrapper: (cb) => {
            const result = cb();
            detectChangesForMountedFixtures();
            return result;
        },
        ...domConfig,
    });
    TestBed.configureTestingModule({
        declarations: addAutoDeclarations(sut, {
            declarations,
            excludeComponentDeclaration,
            wrapper,
        }),
        imports: addAutoImports({
            imports: imports.concat(defaultImports),
            routes,
        }),
        providers: [...providers],
        schemas: [...schemas],
    });
    await TestBed.compileComponents();
    componentProviders
        .reduce((acc, provider) => acc.concat(provider), [])
        .forEach((p) => {
        const { provide, ...provider } = p;
        TestBed.overrideProvider(provide, provider);
    });
    const componentContainer = createComponentFixture(sut, wrapper);
    let fixture;
    let detectChanges;
    await renderFixture(componentProperties);
    const rerender = async (rerenderedProperties) => {
        await renderFixture(rerenderedProperties);
    };
    const change = (changedProperties) => {
        const changes = getChangesObj(fixture.componentInstance, changedProperties);
        setComponentProperties(fixture, { componentProperties: changedProperties });
        if (hasOnChangesHook(fixture.componentInstance)) {
            fixture.componentInstance.ngOnChanges(changes);
        }
        fixture.componentRef.injector.get(ChangeDetectorRef).detectChanges();
    };
    const zone = inject(NgZone);
    const router = inject(Router);
    if (typeof router?.initialNavigation === 'function') {
        router?.initialNavigation();
    }
    const navigate = async (elementOrPath, basePath = '') => {
        const href = typeof elementOrPath === 'string' ? elementOrPath : elementOrPath.getAttribute('href');
        const [path, params] = (basePath + href).split('?');
        const queryParams = params
            ? params.split('&').reduce((qp, q) => {
                const [key, value] = q.split('=');
                const currentValue = qp[key];
                if (typeof currentValue === 'undefined') {
                    qp[key] = value;
                }
                else if (Array.isArray(currentValue)) {
                    qp[key] = [...currentValue, value];
                }
                else {
                    qp[key] = [currentValue, value];
                }
                return qp;
            }, {})
            : undefined;
        const navigateOptions = queryParams
            ? {
                queryParams,
            }
            : undefined;
        const doNavigate = () => {
            return navigateOptions ? router?.navigate([path], navigateOptions) : router?.navigate([path]);
        };
        let result;
        if (zone) {
            await zone.run(() => (result = doNavigate()));
        }
        else {
            result = doNavigate();
        }
        detectChanges();
        return result ?? false;
    };
    return {
        // @ts-ignore: fixture assigned
        fixture,
        detectChanges: () => detectChanges(),
        navigate,
        rerender,
        change,
        // @ts-ignore: fixture assigned
        debugElement: typeof sut === 'string' ? fixture.debugElement : fixture.debugElement.query(By.directive(sut)),
        // @ts-ignore: fixture assigned
        container: fixture.nativeElement,
        debug: (element = fixture.nativeElement, maxLength, options) => Array.isArray(element)
            ? element.forEach((e) => console.log(prettyDOM(e, maxLength, options)))
            : console.log(prettyDOM(element, maxLength, options)),
        // @ts-ignore: fixture assigned
        ...replaceFindWithFindAndDetectChanges(getQueriesForElement(fixture.nativeElement, queries)),
    };
    async function renderFixture(properties) {
        if (fixture) {
            cleanupAtFixture(fixture);
        }
        fixture = await createComponent(componentContainer);
        setComponentProperties(fixture, { componentProperties: properties });
        if (removeAngularAttributes) {
            fixture.nativeElement.removeAttribute('ng-version');
            const idAttribute = fixture.nativeElement.getAttribute('id');
            if (idAttribute && idAttribute.startsWith('root')) {
                fixture.nativeElement.removeAttribute('id');
            }
        }
        mountedFixtures.add(fixture);
        let isAlive = true;
        fixture.componentRef.onDestroy(() => (isAlive = false));
        if (hasOnChangesHook(fixture.componentInstance)) {
            const changes = getChangesObj(null, componentProperties);
            fixture.componentInstance.ngOnChanges(changes);
        }
        detectChanges = () => {
            if (isAlive) {
                fixture.detectChanges();
            }
        };
        if (detectChangesOnRender) {
            detectChanges();
        }
    }
}
async function createComponent(component) {
    /* Make sure angular application is initialized before creating component */
    await inject(ApplicationInitStatus).donePromise;
    return TestBed.createComponent(component);
}
function createComponentFixture(sut, wrapper) {
    if (typeof sut === 'string') {
        TestBed.overrideTemplate(wrapper, sut);
        return wrapper;
    }
    return sut;
}
function setComponentProperties(fixture, { componentProperties = {} }) {
    for (const key of Object.keys(componentProperties)) {
        const descriptor = Object.getOwnPropertyDescriptor(fixture.componentInstance.constructor.prototype, key);
        let _value = componentProperties[key];
        const defaultGetter = () => _value;
        const extendedSetter = (value) => {
            _value = value;
            descriptor?.set?.call(fixture.componentInstance, _value);
            fixture.detectChanges();
        };
        Object.defineProperty(fixture.componentInstance, key, {
            get: descriptor?.get || defaultGetter,
            set: extendedSetter,
            // Allow the property to be defined again later.
            // This happens when the component properties are updated after initial render.
            // For Jest this is `true` by default, for Karma and a real browser the default is `false`
            configurable: true,
        });
        descriptor?.set?.call(fixture.componentInstance, _value);
    }
    return fixture;
}
function hasOnChangesHook(componentInstance) {
    return ('ngOnChanges' in componentInstance && typeof componentInstance.ngOnChanges === 'function');
}
function getChangesObj(oldProps, newProps) {
    const isFirstChange = oldProps === null;
    return Object.keys(newProps).reduce((changes, key) => ({
        ...changes,
        [key]: new SimpleChange(isFirstChange ? null : oldProps[key], newProps[key], isFirstChange),
    }), {});
}
function addAutoDeclarations(sut, { declarations = [], excludeComponentDeclaration, wrapper, }) {
    if (typeof sut === 'string') {
        return [...declarations, wrapper];
    }
    const components = () => (excludeComponentDeclaration ? [] : [sut]);
    return [...declarations, ...components()];
}
function addAutoImports({ imports = [], routes }) {
    const animations = () => {
        const animationIsDefined = imports.indexOf(NoopAnimationsModule) > -1 || imports.indexOf(BrowserAnimationsModule) > -1;
        return animationIsDefined ? [] : [NoopAnimationsModule];
    };
    const routing = () => (routes ? [RouterTestingModule.withRoutes(routes)] : []);
    return [...imports, ...animations(), ...routing()];
}
/**
 * Wrap waitFor to invoke the Angular change detection cycle before invoking the callback
 */
async function waitForWrapper(detectChanges, callback, options) {
    let inFakeAsync = true;
    try {
        tick(0);
    }
    catch (err) {
        inFakeAsync = false;
    }
    detectChanges();
    return await waitFor$1(() => {
        setTimeout(() => detectChanges(), 0);
        if (inFakeAsync) {
            tick(0);
        }
        return callback();
    }, options);
}
/**
 * Wrap waitForElementToBeRemovedWrapper to poke the Angular change detection cycle before invoking the callback
 */
async function waitForElementToBeRemovedWrapper(detectChanges, callback, options) {
    let cb;
    if (typeof callback !== 'function') {
        const elements = (Array.isArray(callback) ? callback : [callback]);
        const getRemainingElements = elements.map((element) => {
            let parent = element.parentElement;
            while (parent.parentElement) {
                parent = parent.parentElement;
            }
            return () => (parent.contains(element) ? element : null);
        });
        cb = () => getRemainingElements.map((c) => c()).find(Boolean);
    }
    else {
        cb = callback;
    }
    return await waitForElementToBeRemoved$1(() => {
        const result = cb();
        detectChanges();
        return result;
    }, options);
}
function cleanup() {
    mountedFixtures.forEach(cleanupAtFixture);
}
function cleanupAtFixture(fixture) {
    fixture.destroy();
    if (!fixture.nativeElement.getAttribute('ng-version') && fixture.nativeElement.parentNode === document.body) {
        document.body.removeChild(fixture.nativeElement);
    }
    mountedFixtures.delete(fixture);
}
// if we're running in a test runner that supports afterEach
// then we'll automatically run cleanup afterEach test
// this ensures that tests run in isolation from each other
// if you don't like this, set the ATL_SKIP_AUTO_CLEANUP env variable to 'true'
if (typeof process === 'undefined' || !process.env?.ATL_SKIP_AUTO_CLEANUP) {
    if (typeof afterEach === 'function') {
        afterEach(() => {
            cleanup();
        });
    }
}
class WrapperComponent {
}
WrapperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: WrapperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
WrapperComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: WrapperComponent, selector: "atl-wrapper-component", ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: WrapperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'atl-wrapper-component', template: '' }]
        }] });
/**
 * Wrap findBy queries to poke the Angular change detection cycle
 */
function replaceFindWithFindAndDetectChanges(originalQueriesForContainer) {
    return Object.keys(originalQueriesForContainer).reduce((newQueries, key) => {
        const getByQuery = originalQueriesForContainer[key.replace('find', 'get')];
        if (key.startsWith('find') && getByQuery) {
            newQueries[key] = async (...queryOptions) => {
                const waitOptions = queryOptions.length === 3 ? queryOptions.pop() : undefined;
                // original implementation at https://github.com/testing-library/dom-testing-library/blob/main/src/query-helpers.js
                return await waitForWrapper(detectChangesForMountedFixtures, () => getByQuery(...queryOptions), waitOptions);
            };
        }
        else {
            newQueries[key] = originalQueriesForContainer[key];
        }
        return newQueries;
    }, {});
}
/**
 * Call detectChanges for all fixtures
 */
function detectChangesForMountedFixtures() {
    mountedFixtures.forEach((fixture) => {
        try {
            fixture.detectChanges();
        }
        catch (err) {
            if (!err.message.startsWith('ViewDestroyedError')) {
                throw err;
            }
        }
    });
}
/**
 * Re-export screen with patched queries
 */
const screen = replaceFindWithFindAndDetectChanges(screen$1);
/**
 * Re-export within with patched queries
 */
const within = (element, queriesToBind) => {
    const container = within$1(element, queriesToBind);
    return replaceFindWithFindAndDetectChanges(container);
};
/**
 * Re-export waitFor with patched waitFor
 */
async function waitFor(callback, options) {
    return waitForWrapper(detectChangesForMountedFixtures, callback, options);
}
/**
 * Re-export waitForElementToBeRemoved with patched waitForElementToBeRemoved
 */
async function waitForElementToBeRemoved(callback, options) {
    return waitForElementToBeRemovedWrapper(detectChangesForMountedFixtures, callback, options);
}

/*
 * Public API Surface of testing-library
 */

/**
 * Generated bundle index. Do not edit.
 */

export { configure, getConfig, render, screen, waitFor, waitForElementToBeRemoved, within };
//# sourceMappingURL=testing-library-angular.mjs.map
