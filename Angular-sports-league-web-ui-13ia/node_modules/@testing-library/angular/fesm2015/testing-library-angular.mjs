import { __awaiter, __rest } from 'tslib';
import * as i0 from '@angular/core';
import { ApplicationInitStatus, SimpleChange, ChangeDetectorRef, NgZone, Component } from '@angular/core';
import { TestBed, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { NoopAnimationsModule, BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { Router } from '@angular/router';
import { RouterTestingModule } from '@angular/router/testing';
import { configure as configure$1, prettyDOM, getQueriesForElement, waitFor as waitFor$1, waitForElementToBeRemoved as waitForElementToBeRemoved$1, screen as screen$1, within as within$1 } from '@testing-library/dom';
export { buildQueries, createEvent, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, isInaccessible, logDOM, logRoles, prettyDOM, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers } from '@testing-library/dom';

let config = {
    dom: {},
    defaultImports: [],
};
function configure(newConfig) {
    if (typeof newConfig === 'function') {
        // Pass the existing config out to the provided function
        // and accept a delta in return
        newConfig = newConfig(config);
    }
    // Merge the incoming config delta
    config = Object.assign(Object.assign({}, config), newConfig);
}
function getConfig() {
    return config;
}

var _a;
const mountedFixtures = new Set();
const inject = TestBed.inject || TestBed.get;
function render(sut, renderOptions = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const _a = getConfig(), { dom: domConfig } = _a, globalConfig = __rest(_a, ["dom"]);
        const { detectChanges: detectChangesOnRender = true, declarations = [], imports = [], providers = [], schemas = [], queries, wrapper = WrapperComponent, componentProperties = {}, componentProviders = [], excludeComponentDeclaration = false, routes = [], removeAngularAttributes = false, defaultImports = [], } = Object.assign(Object.assign({}, globalConfig), renderOptions);
        configure$1(Object.assign({ eventWrapper: (cb) => {
                const result = cb();
                detectChangesForMountedFixtures();
                return result;
            } }, domConfig));
        TestBed.configureTestingModule({
            declarations: addAutoDeclarations(sut, {
                declarations,
                excludeComponentDeclaration,
                wrapper,
            }),
            imports: addAutoImports({
                imports: imports.concat(defaultImports),
                routes,
            }),
            providers: [...providers],
            schemas: [...schemas],
        });
        yield TestBed.compileComponents();
        componentProviders
            .reduce((acc, provider) => acc.concat(provider), [])
            .forEach((p) => {
            const { provide } = p, provider = __rest(p, ["provide"]);
            TestBed.overrideProvider(provide, provider);
        });
        const componentContainer = createComponentFixture(sut, wrapper);
        let fixture;
        let detectChanges;
        yield renderFixture(componentProperties);
        const rerender = (rerenderedProperties) => __awaiter(this, void 0, void 0, function* () {
            yield renderFixture(rerenderedProperties);
        });
        const change = (changedProperties) => {
            const changes = getChangesObj(fixture.componentInstance, changedProperties);
            setComponentProperties(fixture, { componentProperties: changedProperties });
            if (hasOnChangesHook(fixture.componentInstance)) {
                fixture.componentInstance.ngOnChanges(changes);
            }
            fixture.componentRef.injector.get(ChangeDetectorRef).detectChanges();
        };
        const zone = inject(NgZone);
        const router = inject(Router);
        if (typeof (router === null || router === void 0 ? void 0 : router.initialNavigation) === 'function') {
            router === null || router === void 0 ? void 0 : router.initialNavigation();
        }
        const navigate = (elementOrPath, basePath = '') => __awaiter(this, void 0, void 0, function* () {
            const href = typeof elementOrPath === 'string' ? elementOrPath : elementOrPath.getAttribute('href');
            const [path, params] = (basePath + href).split('?');
            const queryParams = params
                ? params.split('&').reduce((qp, q) => {
                    const [key, value] = q.split('=');
                    const currentValue = qp[key];
                    if (typeof currentValue === 'undefined') {
                        qp[key] = value;
                    }
                    else if (Array.isArray(currentValue)) {
                        qp[key] = [...currentValue, value];
                    }
                    else {
                        qp[key] = [currentValue, value];
                    }
                    return qp;
                }, {})
                : undefined;
            const navigateOptions = queryParams
                ? {
                    queryParams,
                }
                : undefined;
            const doNavigate = () => {
                return navigateOptions ? router === null || router === void 0 ? void 0 : router.navigate([path], navigateOptions) : router === null || router === void 0 ? void 0 : router.navigate([path]);
            };
            let result;
            if (zone) {
                yield zone.run(() => (result = doNavigate()));
            }
            else {
                result = doNavigate();
            }
            detectChanges();
            return result !== null && result !== void 0 ? result : false;
        });
        return Object.assign({ 
            // @ts-ignore: fixture assigned
            fixture, detectChanges: () => detectChanges(), navigate,
            rerender,
            change, 
            // @ts-ignore: fixture assigned
            debugElement: typeof sut === 'string' ? fixture.debugElement : fixture.debugElement.query(By.directive(sut)), 
            // @ts-ignore: fixture assigned
            container: fixture.nativeElement, debug: (element = fixture.nativeElement, maxLength, options) => Array.isArray(element)
                ? element.forEach((e) => console.log(prettyDOM(e, maxLength, options)))
                : console.log(prettyDOM(element, maxLength, options)) }, replaceFindWithFindAndDetectChanges(getQueriesForElement(fixture.nativeElement, queries)));
        function renderFixture(properties) {
            return __awaiter(this, void 0, void 0, function* () {
                if (fixture) {
                    cleanupAtFixture(fixture);
                }
                fixture = yield createComponent(componentContainer);
                setComponentProperties(fixture, { componentProperties: properties });
                if (removeAngularAttributes) {
                    fixture.nativeElement.removeAttribute('ng-version');
                    const idAttribute = fixture.nativeElement.getAttribute('id');
                    if (idAttribute && idAttribute.startsWith('root')) {
                        fixture.nativeElement.removeAttribute('id');
                    }
                }
                mountedFixtures.add(fixture);
                let isAlive = true;
                fixture.componentRef.onDestroy(() => (isAlive = false));
                if (hasOnChangesHook(fixture.componentInstance)) {
                    const changes = getChangesObj(null, componentProperties);
                    fixture.componentInstance.ngOnChanges(changes);
                }
                detectChanges = () => {
                    if (isAlive) {
                        fixture.detectChanges();
                    }
                };
                if (detectChangesOnRender) {
                    detectChanges();
                }
            });
        }
    });
}
function createComponent(component) {
    return __awaiter(this, void 0, void 0, function* () {
        /* Make sure angular application is initialized before creating component */
        yield inject(ApplicationInitStatus).donePromise;
        return TestBed.createComponent(component);
    });
}
function createComponentFixture(sut, wrapper) {
    if (typeof sut === 'string') {
        TestBed.overrideTemplate(wrapper, sut);
        return wrapper;
    }
    return sut;
}
function setComponentProperties(fixture, { componentProperties = {} }) {
    var _a;
    for (const key of Object.keys(componentProperties)) {
        const descriptor = Object.getOwnPropertyDescriptor(fixture.componentInstance.constructor.prototype, key);
        let _value = componentProperties[key];
        const defaultGetter = () => _value;
        const extendedSetter = (value) => {
            var _a;
            _value = value;
            (_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set) === null || _a === void 0 ? void 0 : _a.call(fixture.componentInstance, _value);
            fixture.detectChanges();
        };
        Object.defineProperty(fixture.componentInstance, key, {
            get: (descriptor === null || descriptor === void 0 ? void 0 : descriptor.get) || defaultGetter,
            set: extendedSetter,
            // Allow the property to be defined again later.
            // This happens when the component properties are updated after initial render.
            // For Jest this is `true` by default, for Karma and a real browser the default is `false`
            configurable: true,
        });
        (_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set) === null || _a === void 0 ? void 0 : _a.call(fixture.componentInstance, _value);
    }
    return fixture;
}
function hasOnChangesHook(componentInstance) {
    return ('ngOnChanges' in componentInstance && typeof componentInstance.ngOnChanges === 'function');
}
function getChangesObj(oldProps, newProps) {
    const isFirstChange = oldProps === null;
    return Object.keys(newProps).reduce((changes, key) => (Object.assign(Object.assign({}, changes), { [key]: new SimpleChange(isFirstChange ? null : oldProps[key], newProps[key], isFirstChange) })), {});
}
function addAutoDeclarations(sut, { declarations = [], excludeComponentDeclaration, wrapper, }) {
    if (typeof sut === 'string') {
        return [...declarations, wrapper];
    }
    const components = () => (excludeComponentDeclaration ? [] : [sut]);
    return [...declarations, ...components()];
}
function addAutoImports({ imports = [], routes }) {
    const animations = () => {
        const animationIsDefined = imports.indexOf(NoopAnimationsModule) > -1 || imports.indexOf(BrowserAnimationsModule) > -1;
        return animationIsDefined ? [] : [NoopAnimationsModule];
    };
    const routing = () => (routes ? [RouterTestingModule.withRoutes(routes)] : []);
    return [...imports, ...animations(), ...routing()];
}
/**
 * Wrap waitFor to invoke the Angular change detection cycle before invoking the callback
 */
function waitForWrapper(detectChanges, callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let inFakeAsync = true;
        try {
            tick(0);
        }
        catch (err) {
            inFakeAsync = false;
        }
        detectChanges();
        return yield waitFor$1(() => {
            setTimeout(() => detectChanges(), 0);
            if (inFakeAsync) {
                tick(0);
            }
            return callback();
        }, options);
    });
}
/**
 * Wrap waitForElementToBeRemovedWrapper to poke the Angular change detection cycle before invoking the callback
 */
function waitForElementToBeRemovedWrapper(detectChanges, callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let cb;
        if (typeof callback !== 'function') {
            const elements = (Array.isArray(callback) ? callback : [callback]);
            const getRemainingElements = elements.map((element) => {
                let parent = element.parentElement;
                while (parent.parentElement) {
                    parent = parent.parentElement;
                }
                return () => (parent.contains(element) ? element : null);
            });
            cb = () => getRemainingElements.map((c) => c()).find(Boolean);
        }
        else {
            cb = callback;
        }
        return yield waitForElementToBeRemoved$1(() => {
            const result = cb();
            detectChanges();
            return result;
        }, options);
    });
}
function cleanup() {
    mountedFixtures.forEach(cleanupAtFixture);
}
function cleanupAtFixture(fixture) {
    fixture.destroy();
    if (!fixture.nativeElement.getAttribute('ng-version') && fixture.nativeElement.parentNode === document.body) {
        document.body.removeChild(fixture.nativeElement);
    }
    mountedFixtures.delete(fixture);
}
// if we're running in a test runner that supports afterEach
// then we'll automatically run cleanup afterEach test
// this ensures that tests run in isolation from each other
// if you don't like this, set the ATL_SKIP_AUTO_CLEANUP env variable to 'true'
if (typeof process === 'undefined' || !((_a = process.env) === null || _a === void 0 ? void 0 : _a.ATL_SKIP_AUTO_CLEANUP)) {
    if (typeof afterEach === 'function') {
        afterEach(() => {
            cleanup();
        });
    }
}
class WrapperComponent {
}
WrapperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: WrapperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
WrapperComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: WrapperComponent, selector: "atl-wrapper-component", ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: WrapperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'atl-wrapper-component', template: '' }]
        }] });
/**
 * Wrap findBy queries to poke the Angular change detection cycle
 */
function replaceFindWithFindAndDetectChanges(originalQueriesForContainer) {
    return Object.keys(originalQueriesForContainer).reduce((newQueries, key) => {
        const getByQuery = originalQueriesForContainer[key.replace('find', 'get')];
        if (key.startsWith('find') && getByQuery) {
            newQueries[key] = (...queryOptions) => __awaiter(this, void 0, void 0, function* () {
                const waitOptions = queryOptions.length === 3 ? queryOptions.pop() : undefined;
                // original implementation at https://github.com/testing-library/dom-testing-library/blob/main/src/query-helpers.js
                return yield waitForWrapper(detectChangesForMountedFixtures, () => getByQuery(...queryOptions), waitOptions);
            });
        }
        else {
            newQueries[key] = originalQueriesForContainer[key];
        }
        return newQueries;
    }, {});
}
/**
 * Call detectChanges for all fixtures
 */
function detectChangesForMountedFixtures() {
    mountedFixtures.forEach((fixture) => {
        try {
            fixture.detectChanges();
        }
        catch (err) {
            if (!err.message.startsWith('ViewDestroyedError')) {
                throw err;
            }
        }
    });
}
/**
 * Re-export screen with patched queries
 */
const screen = replaceFindWithFindAndDetectChanges(screen$1);
/**
 * Re-export within with patched queries
 */
const within = (element, queriesToBind) => {
    const container = within$1(element, queriesToBind);
    return replaceFindWithFindAndDetectChanges(container);
};
/**
 * Re-export waitFor with patched waitFor
 */
function waitFor(callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return waitForWrapper(detectChangesForMountedFixtures, callback, options);
    });
}
/**
 * Re-export waitForElementToBeRemoved with patched waitForElementToBeRemoved
 */
function waitForElementToBeRemoved(callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return waitForElementToBeRemovedWrapper(detectChangesForMountedFixtures, callback, options);
    });
}

/*
 * Public API Surface of testing-library
 */

/**
 * Generated bundle index. Do not edit.
 */

export { configure, getConfig, render, screen, waitFor, waitForElementToBeRemoved, within };
//# sourceMappingURL=testing-library-angular.mjs.map
